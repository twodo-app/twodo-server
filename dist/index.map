{"version":3,"sources":["api/todo.js","api/status.js","api/test/todos.js","api/test/index.js","api/v1/todos.js","api/v1/user.js","api/v1/index.js","api/index.js","index.js"],"names":["shortid","require","completeSchema","id","String","userid","title","description","priority","Number","created","due","estimated","timetaken","snoozed","Boolean","complete","requiredSchema","staticFields","validateRequired","todo","Object","keys","reduce","valid","key","validateComplete","validateUpdate","newTodo","oldTodo","create","generate","mock","Math","random","Date","now","module","exports","OK","CREATED","NO_CONTENT","NOT_MODIFIED","BAD_REQUEST","UNAUTHORISED","FORBIDDEN","NOT_FOUND","CONFLICT","INTERNAL_SERVER_ERROR","Todo","get","all","db","_","res","todos","value","status","json","filtered","req","filters","query","push","x","JSON","parse","isNaN","parseInt","predicate","filter","length","byID","find","params","undefined","post","body","sendStatus","write","update","updatedTodo","hasOwnProperty","assign","delete","remove","user","byUser","console","log","newUser","api","test","v1","version","express","bodyParser","cors","lowdb","Adapter","DB_NAME","PORT","process","env","VERSION","ROOT","defaults","users","app","use","listen"],"mappings":"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","file":"index.map","sourceRoot":"../src","sourcesContent":["//---------------------------------------------------------\n// NPM Packages\nconst shortid = require('shortid') // UUID generator\n\n//---------------------------------------------------------\nconst completeSchema = {\n  id          : String,\n  userid      : String,\n  title       : String,\n  description : String,\n  priority    : Number,\n  created     : Number,\n  due         : Number,\n  estimated   : Number,\n  timetaken   : Number,\n  snoozed     : Boolean,\n  complete    : Boolean,\n}\n\nconst requiredSchema = {\n  userid      : String,\n  title       : String,\n  description : String,\n  priority    : Number,\n  created     : Number,\n  due         : Number,\n  estimated   : Number,\n}\n\nconst staticFields = [\n  'id',\n  'userid',\n  'created',\n  'timetaken'\n]\n\n//---------------------------------------------------------\n// A simple validation that checks the types of each field\n// in the todo. In production this should be more advanced,\n// checking both the type and the value, but fo test purposes\n// this is servicable.\nconst validateRequired = todo =>\n  Object.keys(requiredSchema)\n    .reduce((valid, key) => typeof todo[key] === typeof requiredSchema[key]() && valid, true)\n\nconst validateComplete = todo =>\n  Object.keys(completeSchema)\n    .reduce((valid, key) => typeof todo[key] === typeof completeSchema[key]() && valid, true)\n\n// Validation check to ensure the fields defined in staticFields\n// remain unchanged when updating a todo.\nconst validateUpdate = (newTodo, oldTodo) =>\n  staticFields.reduce((valid, key) => newTodo[key] === oldTodo[key] && valid, true)\n\n// Takes a todo with all the fields outlined in requiredSchema\n// and fills in the rest with some sensible defaults.\nconst create = todo => ({\n  id          : shortid.generate(),\n  userid      : todo.userid,\n  title       : todo.title,\n  description : todo.description,\n  priority    : todo.priority,\n  created     : todo.created,\n  due         : todo.due,\n  estimated   : todo.estimated,\n  timetaken   : 0,\n  snoozed     : false,\n  complete    : false\n})\n\n// Used to generate some mock todos for testing purposes.\n// This lets us test some api GET requests without having\n// to POST some todos from the client first.\nconst mock = () => create({\n  userid      : 'test-user',\n  title       : 'I am a mock twodo',\n  description : 'Use me to test the API!',\n  priority    : (Math.random() * 3) | 0,\n  created     : Date.now(),\n  due         : Date.now() + (Math.random() * 100000),\n  estimated   : Date.now() + (Math.random() * 100000)\n})\n\n//---------------------------------------------------------\nmodule.exports = { \n  validateRequired, \n  validateComplete, \n  validateUpdate,\n  create, \n  mock }","module.exports = {\n  // 2XX - Success\n  OK: 200,\n  CREATED: 201,\n  NO_CONTENT: 204,\n  // 3XX - Redirection\n  NOT_MODIFIED: 304,\n  // 4XX - Client Error\n  BAD_REQUEST: 400,\n  UNAUTHORISED: 401,\n  FORBIDDEN: 403,\n  NOT_FOUND: 404,\n  CONFLICT: 409,\n  // 5XX - Server Error\n  INTERNAL_SERVER_ERROR: 500\n}","const shortid = require('shortid')\nconst { \n  OK, \n  CREATED,\n  BAD_REQUEST, \n  NOT_FOUND } = require('../status.js')\nconst Todo    = require('../todo.js')\n\nmodule.exports = {\n  get: {\n    // GET all todos in the database.\n    all: db => (_, res) => {\n      const todos = db.get('todos')\n        .value()  // It is important to end all db queries with either .value()\n                  // or .write() otherwise you won't get the data you were expecting!!\n\n      // Chain methods to set the response status code\n      // and then fire a response with the todos json as\n      // the body. \n      // It's important to call .json() last as it fires off\n      // the response.  \n      res.status(OK).json(todos)\n    },\n    // GET all todos and filter according to some query params.\n    filtered: db => (req, res) => {\n      const filters = []\n\n      if (req.query.complete === 'true' || req.query.complete === 'false')\n        filters.push(x => x.complete === JSON.parse(req.query.complete))\n  \n      if (req.query.snoozed === 'true' || req.query.complete === 'false')\n        filters.push(x => x.snoozed === JSON.parse(req.query.snoozed))\n\n      if (!isNaN( parseInt(req.query.priority )))\n        filters.push(x => x.priority === parseInt(req.query.priority))\n\n      const todos = filters\n        .reduce((todos, predicate) => todos.filter(predicate), db.get('todos'))\n        .value()\n\n      todos.length > 0\n        ? res.status(200).json(todos)\n        : res.status(404).json(todos)\n    },\n    // GET a specific todo by id\n    // In practice this isn't as useful as the POST counterpart.\n    byID : db => (req, res) => {\n      const todo = db.get('todos')\n        .find({ id: req.params.id })\n        .value()\n\n      todo == undefined\n        ? res.status(NOT_FOUND).json({})\n        : res.status(OK).json(todo)\n    }\n  },\n  post: {\n    // \n    create: db => (req, res) => {\n      // Return early if the request has no body.\n      if (!req.body)\n        return res.sendStatus(BAD_REQUEST)\n\n      // Validate the request body to check it has\n      // the required fields and types.\n      if (!Todo.validateRequired(req.body)) {\n        return res.sendStatus(BAD_REQUEST)\n      }\n\n      const todo = Todo.create(req.body)\n\n      db.get('todos').push(todo).write()\n\n      res.status(CREATED).json(todo)\n    },\n    //\n    update: db => (req, res) => {\n      const todo = db.get('todos')\n        .find({ id: req.params.id })\n        .value()\n\n      // Return early if the todo wasn't found.\n      // We can't update what doesn't exist!\n      if (!todo)\n        return res.sendStatus(NOT_FOUND)\n\n      // Return early if the request has no body.\n      if (!req.body)\n        return res.sendStatus(BAD_REQUEST)\n\n      // Validate the request body to check it has\n      // the required fields and types.\n      if (!Todo.validateComplete(req.body))\n        return res.sendStatus(BAD_REQUEST)\n\n      // Iterate over each key in the existing *todo* and update its\n      // value according to corresponding value in the request body. If\n      // the body doesn't have that particular key, just fall back to the\n      // existing todo data.\n      // This is a bad idea(tm) as important keys such as ID and date created\n      // can be overwritten. This should be handled better in production!!\n      const updatedTodo = {}\n      for (const key in todo) {\n        updatedTodo[key] = req.body.hasOwnProperty(key)\n          ? req.body[key]\n          : todo[key]\n      }\n\n      // Validation check to ensure no static fields such as ID or date created\n      // were overwritten.\n      if (!Todo.validateUpdate(updatedTodo, todo))\n        return res.sendStatus(BAD_REQUEST)\n\n      db.get('todos') \n        .find({ id: req.params.id })\n        .assign(updatedTodo)\n        .write()\n\n      res.status(OK).json(updatedTodo)\n    }\n  },\n  delete: {\n    byID: db => (req, res) => {\n      if (!db.get('todos').find({ id: req.params.id }).value())\n        return res.sendStatus(NOT_FOUND)\n\n      db.get('todos')\n        .remove({ id: req.params.id })\n        .write()\n\n      res.sendStatus(OK)\n    }\n  }\n}","// This file exists to provide a single export for\n// each api endpoint. Currently there is only /todos.\nmodule.exports = {\n  todos: require('./todos.js')\n}","const shortid = require('shortid')\nconst { \n  OK, \n  CREATED,\n  BAD_REQUEST, \n  NOT_FOUND } = require('../status.js')\nconst Todo    = require('../todo.js')\n\nmodule.exports = {\n  get: {\n    // GET all todos and filter according to some query params.\n    filtered: db => (req, res) => {\n      const filters = []\n\n      if (req.query.complete === 'true' || req.query.complete === 'false')\n        filters.push(x => x.complete === JSON.parse(req.query.complete))\n  \n      if (req.query.snoozed === 'true' || req.query.complete === 'false')\n        filters.push(x => x.snoozed === JSON.parse(req.query.snoozed))\n\n      if (!isNaN( parseInt(req.query.priority )))\n        filters.push(x => x.priority === parseInt(req.query.priority))\n\n      const todos = filters\n        .reduce((todos, predicate) => todos.filter(predicate), \n          db.get('todos').filter({ userid: req.params.user })\n        )\n        .value()\n\n      todos.length > 0\n        ? res.status(200).json(todos)\n        : res.status(404).json(todos)\n    },\n    // GET a specific todo by id\n    // In practice this isn't as useful as the POST counterpart.\n    byID : db => (req, res) => {\n      const todo = db.get('todos')\n        .get(req.params.user)\n        .find({ id: req.params.id })\n        .value()\n\n      todo == undefined\n        ? res.status(NOT_FOUND).json({})\n        : res.status(OK).json(todo)\n    },\n    byUser: db => (req, res) => {\n      const todos = db.get('todos')\n        .filter({ userid: req.params.user })\n\n      todos.length == 0\n        ? res.status(NOT_FOUND).json([])\n        : res.status(OK).json(todos)\n    }\n  },\n  post: {\n    // \n    create: db => (req, res) => {\n      // Return early if the request has no body.\n      if (!req.body)\n        return res.sendStatus(BAD_REQUEST)\n\n      if (!db.get('users').find(req.params.user).value())\n        return res.sendStatus(BAD_REQUEST)\n\n      // Validate the request body to check it has\n      // the required fields and types.\n      if (!Todo.validateRequired(req.body)) {\n        return res.sendStatus(BAD_REQUEST)\n      }\n\n      const todo = Todo.create(req.body)\n\n      db.get('todos')\n        .push(todo)\n        .write()\n\n      console.log(db.get('todos').value())\n\n      res.status(CREATED).json(todo)\n    },\n    //\n    update: db => (req, res) => {\n      const todo = db.get('todos')\n        .find({ id: req.params.id, userid: req.params.user })\n        .value()\n\n      // Return early if the todo wasn't found.\n      // We can't update what doesn't exist!\n      if (!todo)\n        return res.sendStatus(NOT_FOUND)\n\n      // Return early if the request has no body.\n      if (!req.body)\n        return res.sendStatus(BAD_REQUEST)\n\n      // Validate the request body to check it has\n      // the required fields and types.\n      if (!Todo.validateComplete(req.body))\n        return res.sendStatus(BAD_REQUEST)\n\n      // Iterate over each key in the existing *todo* and update its\n      // value according to corresponding value in the request body. If\n      // the body doesn't have that particular key, just fall back to the\n      // existing todo data.\n      // This is a bad idea(tm) as important keys such as ID and date created\n      // can be overwritten. This should be handled better in production!!\n      const updatedTodo = {}\n      for (const key in todo) {\n        updatedTodo[key] = req.body.hasOwnProperty(key)\n          ? req.body[key]\n          : todo[key]\n      }\n\n      // Validation check to ensure no static fields such as ID or date created\n      // were overwritten.\n      if (!Todo.validateUpdate(updatedTodo, todo))\n        return res.sendStatus(BAD_REQUEST)\n\n      db.get('todos') \n        .find({ id: req.params.id, userid: req.params.user })\n        .assign(updatedTodo)\n        .write()\n\n      res.status(OK).json(updatedTodo)\n    }\n  },\n  delete: {\n    byID: db => (req, res) => {\n      if (!db.get('todos').find({ id: req.params.id, userid: req.params.user }).value())\n        return res.sendStatus(NOT_FOUND)\n\n      db.get('todos')\n        .remove({ id: req.params.id, userid: req.params.user })\n        .write()\n\n      res.sendStatus(OK)\n    }\n  }\n}","const shortid = require('shortid')\nconst { CREATED } = require('../status.js')\n\nmodule.exports = {\n  get: {\n    newUser: db => (req, res) => {\n      const userid = shortid.generate()\n\n      db.get('users')\n        .push(userid)\n        .write()\n\n      res.status(CREATED).json(userid)\n    }\n  }\n}","module.exports = {\n  todos: require('./todos.js'),\n  user: require('./user.js')\n}","const api = {\n  test: require('./test/index.js'),\n  v1: require('./v1/index.js')\n}\n\n// Programmatically determine what version of api to expose.\n// This is necessary because expressions, including string \n// literals cannot be used in a require() call.\nmodule.exports = (version => {\n  switch (version) {\n    case 'test':\n      console.log('loading test api')\n      return api.test\n    case 'v1':\n      console.log('loading v1 api')\n      return api.v1\n    // Fall back to the test api if no version, or an invalid\n    // version is supplied. This should probably default to v1\n    // once in production.\n    default:\n      return api.test\n  }\n})","//---------------------------------------------------------\n// NPM Packages\nconst express     = require('express')                // express is our json server\nconst bodyParser  = require('body-parser')            // express middleware for parsing json bodies\nconst cors        = require('cors')                   // allows cross origin requests\nconst lowdb       = require('lowdb')                  // lowdb is a lightweight json db\nconst Adapter     = require('lowdb/adapters/Memory')  // In test mode the db is saved in memory\nconst Todo        = require('./api/todo.js')\n\n//---------------------------------------------------------\n// Constants\nconst DB_NAME = 'db'\nconst PORT    = process.env.PORT || 3000\nconst VERSION = process.env.VERSION\nconst ROOT    = `/api/${VERSION}`\n\n//---------------------------------------------------------\n// Open the database using the FileSync adapter. Every operation\n// in the database will be synchronous.\nconst db = lowdb( new Adapter(`${DB_NAME}.json`))\n\n// Generate some servicable defaults if we're running the test\n// version of the api. Otherwise initalise an empty database\n// if one does not already exist.\n// .defaults does *not* overwrite data in an existing database.\nVERSION !== 'test'\n  ? db.defaults({ todos: [], users: [ 'andy' ] }).write()\n  : db.defaults({\n    todos: [ Todo.mock(), Todo.mock(), Todo.mock(), Todo.mock() ]\n  }).write()\n\n//---------------------------------------------------------\nconst app = express()\n// Parse 'application/json' request bodies as native json\napp.use(bodyParser.json()) \napp.use(cors()) \n// Allow cross origin requests in dev mode\n// if (VERSION === 'test') app.use(cors())\n// Passing in VERSION lets the api module decide what version\n// of the api to expose. This is useful as a mock api for client\n// testing may not need to be the same as the api exposed in\n// production.  \nconst api = require('./api')(VERSION)\n\nswitch (VERSION) { \n  case 'test':\n    // Handle GET requests\n    app.get( `${ROOT}/todos`, api.todos.get.all(db) )\n    app.get( `${ROOT}/todos/filter?`, api.todos.get.filtered(db) )\n    app.get( `${ROOT}/todos/:id`, api.todos.get.byID(db) )\n    // Handle POST requests\n    app.post( `${ROOT}/todos`, api.todos.post.create(db) )\n    app.post( `${ROOT}/todos/:id`, api.todos.post.update(db) )\n    // Handle DELETE requests\n    app.delete( `${ROOT}/todos/:id`, api.todos.delete.byID(db) )\n    break\n  case 'v1':\n    // Handle GET requests\n    app.get( `${ROOT}/user`, api.user.get.newUser(db) )\n    app.get( `${ROOT}/todos/:user`, api.todos.get.byUser(db) )\n    app.get( `${ROOT}/todos/:user/:id`, api.todos.get.byID(db) )\n    app.get( `${ROOT}/todos/:user/filter?`, api.todos.get.filtered(db) )\n    // Handle POST requests\n    app.post( `${ROOT}/todos`, api.todos.post.create(db) )\n    app.post( `${ROOT}/todos/:user/:id`, api.todos.post.update(db) )\n    // Handle DELETE requests\n    app.delete( `${ROOT}/todos/:user/:id`, api.todos.delete.byID(db) )\n    break\n}\n\napp.listen(PORT, '0.0.0.0', () => {\n  console.log(`Server running on port ${PORT}`)\n})"]}