{"version":3,"sources":["api/todo.js","api/status.js","api/test/todos.js","api/test/index.js","api/v1/todos.js","api/v1/index.js","api/index.js","index.js"],"names":["shortid","require","completeSchema","id","String","title","description","priority","Number","created","due","estimated","timetaken","snoozed","Boolean","complete","requiredSchema","validate","todo","Object","keys","reduce","valid","key","create","generate","mock","Math","random","Date","now","module","exports","OK","CREATED","NO_CONTENT","NOT_MODIFIED","BAD_REQUEST","UNAUTHORISED","FORBIDDEN","NOT_FOUND","CONFLICT","INTERNAL_SERVER_ERROR","Todo","get","all","db","_","res","todos","value","status","json","filtered","req","query","byID","find","params","undefined","post","body","sendStatus","push","write","update","assign","api","test","v1","version","console","log","express","bodyParser","cors","lowdb","Adapter","process","env","VERSION","DB_NAME","PORT","ROOT","defaults","app","use","listen"],"mappings":"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","file":"index.map","sourceRoot":"../src","sourcesContent":["//---------------------------------------------------------\n// NPM Packages\nconst shortid = require('shortid') // UUID generator\n\n//---------------------------------------------------------\nconst completeSchema = {\n  id          : String,\n  title       : String,\n  description : String,\n  priority    : Number,\n  created     : Number,\n  due         : Number,\n  estimated   : Number,\n  timetaken   : Number,\n  snoozed     : Boolean,\n  complete    : Boolean,\n}\n\nconst requiredSchema = {\n  title       : String,\n  description : String,\n  priority    : Number,\n  created     : Number,\n  due         : Number,\n  estimated   : Number,\n}\n\n//---------------------------------------------------------\n// A simple validation that checks the types of each field\n// in the todo. In production this should be more advanced,\n// checking both the type and the value, but fo test purposes\n// this is servicable.\nconst validate = todo => \n  Object.keys(completeSchema).reduce( (valid, key) => \n    (typeof todo[key] === typeof completeSchema[key]() || typeof todo[key] === typeof requiredSchema[key]()) && valid, true )\n\n// Takes a todo with all the fields outlined in requiredSchema\n// and fills in the rest with some sensible defaults.\nconst create = todo => ({\n  id          : shortid.generate(),\n  title       : todo.title,\n  description : todo.description,\n  priority    : todo.priority,\n  created     : todo.created,\n  due         : todo.due,\n  estimated   : todo.estimated,\n  timetaken   : 0,\n  snoozed     : false,\n  complete    : false\n})\n\n// Used to generate some mock todos for testing purposes.\n// This lets us test some api GET requests without having\n// to POST some todos from the client first.\nconst mock = () => create({\n  title       : 'I am a mock twodo',\n  description : 'Use me to test the API!',\n  priority    : (Math.random() * 3) | 0,\n  created     : Date.now(),\n  due         : Date.now() + (Math.random() * 100000),\n  estimated   : Date.now() + (Math.random() * 100000)\n})\n\n//---------------------------------------------------------\nmodule.exports = { validate, create, mock }","module.exports = {\n  // 2XX - Success\n  OK: 200,\n  CREATED: 201,\n  NO_CONTENT: 204,\n  // 3XX - Redirection\n  NOT_MODIFIED: 304,\n  // 4XX - Client Error\n  BAD_REQUEST: 400,\n  UNAUTHORISED: 401,\n  FORBIDDEN: 403,\n  NOT_FOUND: 404,\n  CONFLICT: 409,\n  // 5XX - Server Error\n  INTERNAL_SERVER_ERROR: 500\n}","const shortid = require('shortid')\nconst { \n  OK, \n  CREATED,\n  BAD_REQUEST, \n  NOT_FOUND } = require('../status.js')\nconst Todo    = require('../todo.js')\n\nmodule.exports = {\n  get: {\n    // GET all todos in the database.\n    all: db => (_, res) => {\n      const todos = db.get('todos')\n        .value()  // It is important to end all db queries with either .value()\n                  // or .write() otherwise you won't get the data you were expecting!!\n\n      // Chain methods to set the response status code\n      // and then fire a response with the todos json as\n      // the body. \n      // It's important to call .json() last as it fires off\n      // the response.  \n      res.status(OK).json(todos)\n    },\n    // GET all todos and filter according to some query params.\n    filtered: db => (req, res) => {\n      res.json(`This is all the todos filtered by: ${Object.keys(req.query)}`)\n    },\n    // GET a specific todo by id\n    // In practice this isn't as useful as the POST counterpart.\n    byID : db => (req, res) => {\n      const todo = db.get('todos')\n        .find({ id: req.params.id })\n        .value()\n\n      todo == undefined\n        ? res.status(NOT_FOUND).json({})\n        : res.status(OK).json(todo)\n    }\n  },\n  post: {\n    // \n    create: db => (req, res) => {\n      // Return early if the request has no body.\n      if (!req.body)\n        return res.sendStatus(BAD_REQUEST)\n\n      // Validate the request body to check it has\n      // the required fields and types.\n      if (!Todo.validate(req.body)) {\n        return res.sendStatus(BAD_REQUEST)\n      }\n\n      const todo = Todo.create(req.body)\n\n      db.get('todos').push(todo).write()\n\n      res.status(CREATED).json(todo)\n    },\n    //\n    update: db => (req, res) => {\n      const todo = db.get('todos')\n        .find({ id: req.params.id })\n        .value()\n\n      // Return early if the todo wasn't found.\n      // We can't update what doesn't exist!\n      if (!todo)\n        return res.sendStatus(NOT_FOUND)\n\n      // Return early if the request has no body.\n      if (!req.body)\n        return res.sendStatus(BAD_REQUEST)\n\n      // Validate the request body to check it has\n      // the required fields and types.\n      if (!Todo.validate(req.body)) {\n        return res.sendStatus(BAD_REQUEST)\n      }\n\n      // Iterate over each key in the existing *todo* and update its\n      // value according to corresponding value in the request body. If\n      // the body doesn't have that particular key, just fall back to the\n      // existing todo data.\n      // This is a bad idea(tm) as important keys such as ID and date created\n      // can be overwritten. This should be handled better in production!!\n      for (const key in todo) {\n        todo[key] = req.body[key] || todo[key]\n      }\n\n      db.get('todos') \n        .find({ id: req.params.id })\n        .assign(todo)\n        .write()\n\n      res.status(OK).json(todo)\n    }\n  }\n}","// This file exists to provide a single export for\n// each api endpoint. Currently there is only /todos.\nmodule.exports = {\n  todos: require('./todos.js')\n}","module.exports = {\n  get: {\n    all: db => (req, res) => {\n      res.json('This is all the todos')\n    },\n    //\n    filtered: db => (req, res) => {\n      res.json(`This is all the todos filtered by: ${Object.keys(req.query)}`)\n    },\n    //\n    byID : db => (req, res) => {\n      res.json(`This is the todo with the id: ${req.params.id}`)\n    }\n  },\n  post: db => (req, res) => {\n    \n  }\n}","module.exports = {\n  todos: require('./todos.js')\n}","const api = {\n  test: require('./test/index.js'),\n  v1: require('./v1/index.js')\n}\n\n// Programmatically determine what version of api to expose.\n// This is necessary because expressions, including string \n// literals cannot be used in a require() call.\nmodule.exports = (version => {\n  switch (version) {\n    case 'test':\n      console.log('loading test api')\n      return api.test\n    case 'v1':\n      console.log('loading v1 api')\n      return api.v1\n    // Fall back to the test api if no version, or an invalid\n    // version is supplied. This should probably default to v1\n    // once in production.\n    default:\n      return api.test\n  }\n})","//---------------------------------------------------------\n// NPM Packages\nconst express     = require('express')              // express is our json server\nconst bodyParser  = require('body-parser')          // express middleware for parsing json bodies\nconst cors        = require('cors')                 // allows cross origin requests\nconst shortid     = require('shortid')              // UUID generator\nconst lowdb       = require('lowdb')                // lowdb is a lightweight json db\nconst Adapter     = process.env.VERSION === 'test'\n  ? require('lowdb/adapters/Memory')                // In test mode the db is saved in memory\n  : require('lowdb/adapters/FileSync')              // Otherwise write the db to disk\nconst Todo        = require('./api/todo.js')\n\n//---------------------------------------------------------\n// Constants\nconst DB_NAME = 'db'\nconst PORT    = process.env.PORT || 3000\nconst VERSION = process.env.VERSION\nconst ROOT    = `/api/${VERSION}`\n\n//---------------------------------------------------------\n// db\n// Open the database using the FileSync adapter. Every operation\n// in the database will be synchronous.\nconst db = lowdb( new Adapter(`${DB_NAME}.json`))\n\n// Generate some servicable defaults if we're running the test\n// version of the api. Otherwise initalise an empty database\n// if one does not already exist.\n// .defaults does *not* overwrite data in an existing database.\nVERSION !== 'test'\n  ? db.defaults({ todos: [] }).write()\n  : db.defaults({\n    todos: [ Todo.mock(), Todo.mock(), Todo.mock(), Todo.mock() ]\n  }).write()\n\n//---------------------------------------------------------\nconst app = express()\n// Parse 'application/json' request bodies as native json\napp.use(bodyParser.json())  \n// Allow cross origin requests in dev mode\nif (VERSION === 'dev') app.use(cors())\n// Passing in VERSION lets the api module decide what version\n// of the api to expose. This is useful as a mock api for client\n// testing may not need to be the same as the api exposed in\n// production.  \nconst api = require('./api')(VERSION)\n\n// Handle GET requests\napp.get( `${ROOT}/todos`, api.todos.get.all(db) )\napp.get( `${ROOT}/todos/filter?`, api.todos.get.filtered(db) )\napp.get( `${ROOT}/todos/:id`, api.todos.get.byID(db) )\n// Handle POST requests\napp.post( `${ROOT}/todos`, api.todos.post.create(db) )\napp.post( `${ROOT}/todos/:id`, api.todos.post.update(db) )\n\napp.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`)\n})"]}