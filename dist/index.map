{"version":3,"sources":["api/todo.js","api/status.js","api/test/todos.js","api/test/index.js","api/v1/todos.js","api/v1/index.js","api/index.js","index.js"],"names":["shortid","require","completeSchema","id","String","title","description","priority","Number","created","due","estimated","timetaken","snoozed","Boolean","complete","requiredSchema","staticFields","validateRequired","todo","Object","keys","reduce","valid","key","validateComplete","validateUpdate","newTodo","oldTodo","create","generate","mock","Math","random","Date","now","module","exports","OK","CREATED","NO_CONTENT","NOT_MODIFIED","BAD_REQUEST","UNAUTHORISED","FORBIDDEN","NOT_FOUND","CONFLICT","INTERNAL_SERVER_ERROR","Todo","get","all","db","_","res","todos","value","status","json","filtered","req","filters","query","push","x","JSON","parse","isNaN","parseInt","predicate","filter","length","byID","find","params","undefined","post","body","sendStatus","write","update","updatedTodo","hasOwnProperty","assign","delete","remove","api","test","v1","version","console","log","express","bodyParser","cors","lowdb","Adapter","process","env","VERSION","DB_NAME","PORT","ROOT","defaults","app","use","listen"],"mappings":"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","file":"index.map","sourceRoot":"../src","sourcesContent":["//---------------------------------------------------------\n// NPM Packages\nconst shortid = require('shortid') // UUID generator\n\n//---------------------------------------------------------\nconst completeSchema = {\n  id          : String,\n  title       : String,\n  description : String,\n  priority    : Number,\n  created     : Number,\n  due         : Number,\n  estimated   : Number,\n  timetaken   : Number,\n  snoozed     : Boolean,\n  complete    : Boolean,\n}\n\nconst requiredSchema = {\n  title       : String,\n  description : String,\n  priority    : Number,\n  created     : Number,\n  due         : Number,\n  estimated   : Number,\n}\n\nconst staticFields = [\n  'id',\n  'created',\n  'timetaken'\n]\n\n//---------------------------------------------------------\n// A simple validation that checks the types of each field\n// in the todo. In production this should be more advanced,\n// checking both the type and the value, but fo test purposes\n// this is servicable.\nconst validateRequired = todo =>\n  Object.keys(requiredSchema)\n    .reduce((valid, key) => typeof todo[key] === typeof requiredSchema[key]() && valid, true)\n\nconst validateComplete = todo =>\n  Object.keys(completeSchema)\n    .reduce((valid, key) => typeof todo[key] === typeof completeSchema[key]() && valid, true)\n\n// Validation check to ensure the fields defined in staticFields\n// remain unchanged when updating a todo.\nconst validateUpdate = (newTodo, oldTodo) =>\n  staticFields.reduce((valid, key) => newTodo[key] === oldTodo[key] && valid, true)\n\n// Takes a todo with all the fields outlined in requiredSchema\n// and fills in the rest with some sensible defaults.\nconst create = todo => ({\n  id          : shortid.generate(),\n  title       : todo.title,\n  description : todo.description,\n  priority    : todo.priority,\n  created     : todo.created,\n  due         : todo.due,\n  estimated   : todo.estimated,\n  timetaken   : 0,\n  snoozed     : false,\n  complete    : false\n})\n\n// Used to generate some mock todos for testing purposes.\n// This lets us test some api GET requests without having\n// to POST some todos from the client first.\nconst mock = () => create({\n  title       : 'I am a mock twodo',\n  description : 'Use me to test the API!',\n  priority    : (Math.random() * 3) | 0,\n  created     : Date.now(),\n  due         : Date.now() + (Math.random() * 100000),\n  estimated   : Date.now() + (Math.random() * 100000)\n})\n\n//---------------------------------------------------------\nmodule.exports = { \n  validateRequired, \n  validateComplete, \n  validateUpdate,\n  create, \n  mock }","module.exports = {\n  // 2XX - Success\n  OK: 200,\n  CREATED: 201,\n  NO_CONTENT: 204,\n  // 3XX - Redirection\n  NOT_MODIFIED: 304,\n  // 4XX - Client Error\n  BAD_REQUEST: 400,\n  UNAUTHORISED: 401,\n  FORBIDDEN: 403,\n  NOT_FOUND: 404,\n  CONFLICT: 409,\n  // 5XX - Server Error\n  INTERNAL_SERVER_ERROR: 500\n}","const shortid = require('shortid')\nconst { \n  OK, \n  CREATED,\n  BAD_REQUEST, \n  NOT_FOUND } = require('../status.js')\nconst Todo    = require('../todo.js')\n\nmodule.exports = {\n  get: {\n    // GET all todos in the database.\n    all: db => (_, res) => {\n      const todos = db.get('todos')\n        .value()  // It is important to end all db queries with either .value()\n                  // or .write() otherwise you won't get the data you were expecting!!\n\n      // Chain methods to set the response status code\n      // and then fire a response with the todos json as\n      // the body. \n      // It's important to call .json() last as it fires off\n      // the response.  \n      res.status(OK).json(todos)\n    },\n    // GET all todos and filter according to some query params.\n    filtered: db => (req, res) => {\n      const filters = []\n\n      if (req.query.complete === 'true' || req.query.complete === 'false')\n        filters.push(x => x.complete === JSON.parse(req.query.complete))\n  \n      if (req.query.snoozed === 'true' || req.query.complete === 'false')\n        filters.push(x => x.snoozed === JSON.parse(req.query.snoozed))\n\n      if (!isNaN( parseInt(req.query.priority )))\n        filters.push(x => x.priority === parseInt(req.query.priority))\n\n      const todos = filters\n        .reduce((todos, predicate) => todos.filter(predicate), db.get('todos'))\n        .value()\n\n      todos.length > 0\n        ? res.status(200).json(todos)\n        : res.status(404).json(todos)\n    },\n    // GET a specific todo by id\n    // In practice this isn't as useful as the POST counterpart.\n    byID : db => (req, res) => {\n      const todo = db.get('todos')\n        .find({ id: req.params.id })\n        .value()\n\n      todo == undefined\n        ? res.status(NOT_FOUND).json({})\n        : res.status(OK).json(todo)\n    }\n  },\n  post: {\n    // \n    create: db => (req, res) => {\n      // Return early if the request has no body.\n      if (!req.body)\n        return res.sendStatus(BAD_REQUEST)\n\n      // Validate the request body to check it has\n      // the required fields and types.\n      if (!Todo.validateRequired(req.body)) {\n        return res.sendStatus(BAD_REQUEST)\n      }\n\n      const todo = Todo.create(req.body)\n\n      db.get('todos').push(todo).write()\n\n      res.status(CREATED).json(todo)\n    },\n    //\n    update: db => (req, res) => {\n      const todo = db.get('todos')\n        .find({ id: req.params.id })\n        .value()\n\n      // Return early if the todo wasn't found.\n      // We can't update what doesn't exist!\n      if (!todo)\n        return res.sendStatus(NOT_FOUND)\n\n      // Return early if the request has no body.\n      if (!req.body)\n        return res.sendStatus(BAD_REQUEST)\n\n      // Validate the request body to check it has\n      // the required fields and types.\n      if (!Todo.validateComplete(req.body))\n        return res.sendStatus(BAD_REQUEST)\n\n      // Iterate over each key in the existing *todo* and update its\n      // value according to corresponding value in the request body. If\n      // the body doesn't have that particular key, just fall back to the\n      // existing todo data.\n      // This is a bad idea(tm) as important keys such as ID and date created\n      // can be overwritten. This should be handled better in production!!\n      const updatedTodo = {}\n      for (const key in todo) {\n        updatedTodo[key] = req.body.hasOwnProperty(key)\n          ? req.body[key]\n          : todo[key]\n      }\n\n      // Validation check to ensure no static fields such as ID or date created\n      // were overwritten.\n      if (!Todo.validateUpdate(updatedTodo, todo))\n        return res.sendStatus(BAD_REQUEST)\n\n      db.get('todos') \n        .find({ id: req.params.id })\n        .assign(todo)\n        .write()\n\n      res.status(OK).json(todo)\n    }\n  },\n  delete: {\n    byID: db => (req, res) => {\n      // if (!db.get('todos').find({ id: req.params.id }).value())\n      //   return res.sendStatus(NOT_FOUND)\n\n      db.get('todos')\n        .remove({ id: req.params.id })\n        .write()\n\n      res.sendStatus(OK)\n    }\n  }\n}","// This file exists to provide a single export for\n// each api endpoint. Currently there is only /todos.\nmodule.exports = {\n  todos: require('./todos.js')\n}","module.exports = {\n  get: {\n    all: db => (req, res) => {\n      res.json('This is all the todos')\n    },\n    //\n    filtered: db => (req, res) => {\n      res.json(`This is all the todos filtered by: ${Object.keys(req.query)}`)\n    },\n    //\n    byID : db => (req, res) => {\n      res.json(`This is the todo with the id: ${req.params.id}`)\n    }\n  },\n  post: db => (req, res) => {\n    \n  }\n}","module.exports = {\n  todos: require('./todos.js')\n}","const api = {\n  test: require('./test/index.js'),\n  v1: require('./v1/index.js')\n}\n\n// Programmatically determine what version of api to expose.\n// This is necessary because expressions, including string \n// literals cannot be used in a require() call.\nmodule.exports = (version => {\n  switch (version) {\n    case 'test':\n      console.log('loading test api')\n      return api.test\n    case 'v1':\n      console.log('loading v1 api')\n      return api.v1\n    // Fall back to the test api if no version, or an invalid\n    // version is supplied. This should probably default to v1\n    // once in production.\n    default:\n      return api.test\n  }\n})","//---------------------------------------------------------\n// NPM Packages\nconst express     = require('express')              // express is our json server\nconst bodyParser  = require('body-parser')          // express middleware for parsing json bodies\nconst cors        = require('cors')                 // allows cross origin requests\nconst shortid     = require('shortid')              // UUID generator\nconst lowdb       = require('lowdb')                // lowdb is a lightweight json db\nconst Adapter     = process.env.VERSION === 'test'\n  ? require('lowdb/adapters/Memory')                // In test mode the db is saved in memory\n  : require('lowdb/adapters/FileSync')              // Otherwise write the db to disk\nconst Todo        = require('./api/todo.js')\n\n//---------------------------------------------------------\n// Constants\nconst DB_NAME = 'db'\nconst PORT    = process.env.PORT || 3000\nconst VERSION = process.env.VERSION\nconst ROOT    = `/api/${VERSION}`\n\n//---------------------------------------------------------\n// Open the database using the FileSync adapter. Every operation\n// in the database will be synchronous.\nconst db = lowdb( new Adapter(`${DB_NAME}.json`))\n\n// Generate some servicable defaults if we're running the test\n// version of the api. Otherwise initalise an empty database\n// if one does not already exist.\n// .defaults does *not* overwrite data in an existing database.\nVERSION !== 'test'\n  ? db.defaults({ todos: [] }).write()\n  : db.defaults({\n    todos: [ Todo.mock(), Todo.mock(), Todo.mock(), Todo.mock() ]\n  }).write()\n\n//---------------------------------------------------------\nconst app = express()\n// Parse 'application/json' request bodies as native json\napp.use(bodyParser.json())  \n// Allow cross origin requests in dev mode\nif (VERSION === 'test') app.use(cors())\n// Passing in VERSION lets the api module decide what version\n// of the api to expose. This is useful as a mock api for client\n// testing may not need to be the same as the api exposed in\n// production.  \nconst api = require('./api')(VERSION)\n\n// Handle GET requests\napp.get( `${ROOT}/todos`, api.todos.get.all(db) )\napp.get( `${ROOT}/todos/filter?`, api.todos.get.filtered(db) )\napp.get( `${ROOT}/todos/:id`, api.todos.get.byID(db) )\n// Handle POST requests\napp.post( `${ROOT}/todos`, api.todos.post.create(db) )\napp.post( `${ROOT}/todos/:id`, api.todos.post.update(db) )\n// Handle DELETE requests\napp.delete( `${ROOT}/todos/:id`, api.todos.delete.byID(db) )\n\napp.listen(PORT, '0.0.0.0', () => {\n  console.log(`Server running on port ${PORT}`)\n})"]}